# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14rD9QiMnsD-nK6zv5B74G8FDp96FC7M3
"""

"Création de fonction mathématique simple en Python"

import numpy as np
import numpy.polynomial.polynomial as nppol
import matplotlib.pyplot as plt

x= int(input())
def A(x):
    return (x**3)-(1.5*x**2)-(6*x)+5

print(A(x))

a= int(input("entrez une valeur :" ))

"a fonction factorielle"

def factorielle(a):
   if n == 0:
      return 1
   else:
      F = 1
      for k in range(2,a+1):
         F = F * k

      return F;

print("la factorielle de a est " ,factorielle(a))

"Implémenter la suite de Fibonnaci"

def fibonacci(n):
    if(n <= 1):
        return n
    else:
        return (fibonacci(n-1) + fibonacci(n-2))
n = int(input("Entrez un nombre :"))
print(" La Suite de Fibonacci est :")
for i in range(n):
    print(fibonacci(i))

"Création de fonction comportant des modules de gestions des execption"

import math

def A(x):

        if (type(a) == str) :
            print (" Il est impossible de saisir une chaine de caractére")
            print (" veuillez saisir des valeurs numérique")

         
        elif (type(a) == complex) or (type(b) == complex):
           print (" Nous ne pouvons pas choisir un nombre complexe")
        while (type(a) == complex):
              x = int(input(x," Veuillez saisir un nombre numérique pour x"))      
        if (x < 0):
         print (" nous ne pouvons pas choisir un numéro négatif")
        elif (len(str(x)) > 100):
         print ("la valeur que vous avez taper est supérieur à 100 unités")
x= int(input(""))
A =(x**3)-(1.5*x**2)-(6*x)+5
            return A(x)

"Implémentation de la formule Pricer d’option avec python"

from math import log, sqrt, pi, exp
from scipy.stats import norm
from datetime import datetime, date
import numpy as np
import pandas as pd
from pandas import DataFrame

def d1(S,K,T,r,sigma):
    return(log(S/K)+(r+sigma**2/2.)*T)/(sigma*sqrt(T))
def d2(S,K,T,r,sigma):
    return d1(S,K,T,r,sigma)-sigma*sqrt(T)
def bs_call(S,K,T,r,sigma):
    return S*norm.cdf(d1(S,K,T,r,sigma))-K*exp(-r*T)*norm.cdf(d2(S,K,T,r,sigma))
  
def bs_put(S,K,T,r,sigma):
    return K*exp(-r*T)-S+bs_call(S,K,T,r,sigma)